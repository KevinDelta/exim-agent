-- Migration: Create weekly_pulse_digests table for storing compliance pulse data
-- Description: Primary storage for weekly compliance pulse digests (Supabase/Postgres)
-- Author: Compliance Pulse System
-- Date: 2025-11-01

-- Create the weekly_pulse_digests table
CREATE TABLE IF NOT EXISTS weekly_pulse_digests (
  id BIGSERIAL PRIMARY KEY,
  client_id TEXT NOT NULL,
  period_start TIMESTAMPTZ NOT NULL,
  period_end TIMESTAMPTZ NOT NULL,
  total_changes INT NOT NULL DEFAULT 0,
  high_priority_changes INT NOT NULL DEFAULT 0,
  medium_priority_changes INT NOT NULL DEFAULT 0,
  low_priority_changes INT NOT NULL DEFAULT 0,
  requires_action BOOLEAN NOT NULL DEFAULT FALSE,
  status TEXT NOT NULL,
  digest_data JSONB NOT NULL,
  generated_at TIMESTAMPTZ NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  
  -- Constraints
  CONSTRAINT valid_status CHECK (status IN ('action_required', 'monitoring', 'no_changes', 'error')),
  CONSTRAINT valid_period CHECK (period_end > period_start),
  CONSTRAINT valid_changes CHECK (
    total_changes >= 0 AND 
    high_priority_changes >= 0 AND 
    medium_priority_changes >= 0 AND 
    low_priority_changes >= 0
  )
);

-- Create indexes for fast queries
CREATE INDEX IF NOT EXISTS idx_weekly_pulse_client_period 
  ON weekly_pulse_digests(client_id, period_end DESC);

CREATE INDEX IF NOT EXISTS idx_weekly_pulse_requires_action 
  ON weekly_pulse_digests(requires_action, period_end DESC) 
  WHERE requires_action = TRUE;

CREATE INDEX IF NOT EXISTS idx_weekly_pulse_status 
  ON weekly_pulse_digests(status, period_end DESC);

CREATE INDEX IF NOT EXISTS idx_weekly_pulse_generated_at 
  ON weekly_pulse_digests(generated_at DESC);

-- Create GIN index for JSONB queries on digest_data
CREATE INDEX IF NOT EXISTS idx_weekly_pulse_digest_data 
  ON weekly_pulse_digests USING GIN (digest_data);

-- Create trigger to auto-update updated_at timestamp
CREATE OR REPLACE FUNCTION update_weekly_pulse_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_update_weekly_pulse_updated_at
  BEFORE UPDATE ON weekly_pulse_digests
  FOR EACH ROW
  EXECUTE FUNCTION update_weekly_pulse_updated_at();

-- Add comments for documentation
COMMENT ON TABLE weekly_pulse_digests IS 'Stores weekly compliance pulse digests for clients';
COMMENT ON COLUMN weekly_pulse_digests.client_id IS 'Unique client identifier';
COMMENT ON COLUMN weekly_pulse_digests.period_start IS 'Start of the pulse period';
COMMENT ON COLUMN weekly_pulse_digests.period_end IS 'End of the pulse period';
COMMENT ON COLUMN weekly_pulse_digests.total_changes IS 'Total number of compliance changes detected';
COMMENT ON COLUMN weekly_pulse_digests.high_priority_changes IS 'Number of high priority changes requiring immediate action';
COMMENT ON COLUMN weekly_pulse_digests.requires_action IS 'Whether the digest contains actionable items';
COMMENT ON COLUMN weekly_pulse_digests.status IS 'Overall status: action_required, monitoring, no_changes, error';
COMMENT ON COLUMN weekly_pulse_digests.digest_data IS 'Full JSON digest including all changes, snapshots, and analysis';
COMMENT ON COLUMN weekly_pulse_digests.generated_at IS 'Timestamp when the digest was generated by the pipeline';

-- Enable Row Level Security (RLS) for multi-tenant access
ALTER TABLE weekly_pulse_digests ENABLE ROW LEVEL SECURITY;

-- Create RLS policy: Users can only see their own client's digests
CREATE POLICY client_isolation_policy ON weekly_pulse_digests
  FOR SELECT
  USING (client_id = current_setting('app.current_client_id', TRUE)::TEXT);

-- Create policy for service role to access all digests
CREATE POLICY service_role_policy ON weekly_pulse_digests
  FOR ALL
  USING (current_setting('request.jwt.claims', TRUE)::json->>'role' = 'service_role');
